 ---
/**
 * System (Scrollytelling, variante)
 * - Abre con la frase clave en bloque destacado (full width)
 * - Luego, escenas con progreso sticky (similar a Projects/Reflections)
 * - Sin imágenes, puro texto y foco en estrategia
 */

const frase = "Ningún actor puede controlar el entorno sin igualarlo en complejidad; y si no puede igualarlo, debe aprender a domesticarlo.";

const pasos = [
  {
    id: "s1-variedad",
    titulo: "Variedad requerida (Ashby)",
    texto: "Equilibrar la complejidad del entorno: múltiples públicos, medios y temporalidades. La estrategia debe igualar o domesticar la variedad sin caer en el ruido.",
    detalle: "Definimos umbrales de acción, protocolos de priorización y rutas narrativas para evitar tácticas reactivas."
  },
  {
    id: "s2-diagnostico",
    titulo: "Diagnóstico de entorno",
    texto: "Lectura integrada: señales débiles y fuertes, agenda pública, interlocutores, contextos territoriales y regulatorios.",
    detalle: "Cartografías de actores, riesgos y oportunidades; hipótesis de conflicto y ventanas de oportunidad."
  },
  {
    id: "s3-arquitectura",
    titulo: "Arquitectura de mensajes",
    texto: "Mensajes coherentes pero adaptables entre niveles: centro–regiones, vocerías y formatos.",
    detalle: "Definimos framing, argumentos, cadencia y evidencias; control de consistencia para evitar disonancias."
  },
  {
    id: "s4-ejecucion",
    titulo: "Ejecución multicanal",
    texto: "Operación coordinada en prensa, redes, comunicación interna y terreno.",
    detalle: "Contenido con propósito, no ‘llenado de feed’. Priorizamos impacto y métricas accionables."
  },
  {
    id: "s5-aprendizaje",
    titulo: "Métricas y aprendizaje",
    texto: "Cierre de ciclo con indicadores que explican la realidad, no vanidad.",
    detalle: "Ajuste iterativo, documentación de aprendizajes y mejora continua del sistema."
  }
];
---

<section id="sistema" class="section scenes">
  <div class="container scenes-layout">
    <h2 class="h2" style="grid-column:1 / -1; margin-bottom:.25rem;">Sistema</h2>

    <!-- Frase destacada a todo lo ancho -->
    <div class="card emphasis" style="grid-column:1 / -1; margin-bottom:1.25rem; padding:1.1rem 1.25rem;">
      <p class="system-phrase" style="margin:0;">
        {frase}
      </p>
    </div>

    <!-- Barra de progreso (sticky) con gradiente invertido para distinguir -->
    <aside class="scenes-progress" aria-hidden="true">
      <div class="progress-track">
        <div class="progress-thumb" id="progressSystem" style="background:linear-gradient(180deg,var(--copper),var(--accent));"></div>
      </div>
      <ul class="progress-labels" id="labelsSystem">
        {pasos.map((p, i) => <li class="progress-label" data-index={i}>{p.titulo}</li>)}
      </ul>
    </aside>

    <!-- Escenas -->
    <div class="scenes-col" id="colSystem">
      {pasos.map((p, i) => (
        <article class="scene reveal" id={p.id} data-index={i} aria-current="false">
          <header class="pin-step-head">
            <span class="step-index">{String(i+1).padStart(2,"0")}</span>
            <h3 style="margin:.2rem 0 .35rem; font-weight:800;">{p.titulo}</h3>
          </header>
          <p class="pin-step-text">{p.texto}</p>
          {p.detalle && <p class="pin-step-detail">{p.detalle}</p>}
        </article>
      ))}
    </div>
  </div>
</section>

<script is:inline>
  // IDs únicos para System
  const col    = document.getElementById('colSystem');
  const scenes = Array.from(col.querySelectorAll('.scene'));
  const bar    = document.getElementById('progressSystem');
  const labels = Array.from(document.getElementById('labelsSystem').children);

  const active = new Set();

  // Leve variación de umbrales vs. otras secciones para que la activación se sienta distinta
  const io = new IntersectionObserver((entries)=>{
    for(const e of entries){
      const el = e.target;
      if(e.isIntersecting){ active.add(el); } else { active.delete(el); }
      const current = [...active].sort((a,b)=> a.dataset.index - b.dataset.index).at(-1);
      if(current){
        scenes.forEach(sc => sc.classList.toggle('is-active', sc === current));
        scenes.forEach(sc => sc.setAttribute('aria-current', sc === current ? 'true' : 'false'));
        labels.forEach((lb, i) => lb.classList.toggle('is-on', i <= Number(current.dataset.index)));
        const p = (Number(current.dataset.index)+1) / scenes.length;
        bar.style.transform = `scaleY(${Math.max(0.05, p)})`;
      }
    }
  }, { rootMargin: "-25% 0px -35% 0px", threshold: 0.5 });

  scenes.forEach(s => io.observe(s));

  // Aparición suave
  const ap = new IntersectionObserver((es)=>{
    for(const e of es) e.target.classList.toggle("reveal--in", e.isIntersecting);
  }, { threshold: 0.2 });
  scenes.forEach(el => ap.observe(el));
</script>