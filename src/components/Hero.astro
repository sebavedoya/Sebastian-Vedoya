---
export interface Props {
  cv?: string;
  foto?: string; // puede venir relativa "/assets/..." o absoluta "https://..."
}

const { cv, foto } = Astro.props;

// ✅ BASE_URL dinámico ("/" en local, "/Sebastian-Vedoya" en GitHub Pages)
const BASE = (import.meta.env.BASE_URL || "/").replace(/\/+$/, "");

// ✅ Resolver CV (si no viene desde prop)
const cvUrl = cv
  ? (/^https?:\/\//i.test(cv) ? cv : `${BASE}${cv.startsWith("/") ? cv : `/${cv}`}`)
  : `${BASE}/files/CV.pdf`;

// ✅ Resolver foto (si no viene desde prop)
const fotoUrl = foto
  ? (/^https?:\/\//i.test(foto) ? foto : `${BASE}${foto.startsWith("/") ? foto : `/${foto}`}`)
  : `${BASE}/assets/foto-hero.jpeg`;
---

<!--
  Nuevo HERO:
  - Bloque central (nombre + descripción).
  - “Fase tardía” (foto + chips) que aparece TEMPRANO (≈10% scroll dentro del hero).
-->
<section id="inicio" class="hero section reveal hero--center">
  <div class="container hero-shell">
    <!-- Bloque central -->
    <div class="hero-core">
      <h1 class="hero-title">
        Sebastián Vedoya M.
        <span class="hero-sub">Comunicación Estratégica</span>
      </h1>
      <p class="lead hero-lead">
        Estratega en comunicación con más de 10 años de experiencia en medios y gobierno.
        Me dedico a buscar respuestas complejas para entornos complejos.
      </p>
    </div>

    <!-- Fase tardía: aparece temprano al empezar el scroll -->
    <div class="hero-late">
      <div class="hero-photo-wrap">
        <!-- ✅ foto robusta para GitHub Pages -->
        <img src={fotoUrl} alt="Sebastián Vedoya M." loading="lazy" />
      </div>

      <div class="cta-row">
        <!-- ✅ usa cvUrl con base absoluta -->
        <a class="btn" href={cvUrl} download>Descargar CV</a>
        <a class="chip" href="mailto:seba.vedoya@gmail.com">seba.vedoya@gmail.com</a>
        <a class="chip" href="https://www.linkedin.com/in/sebastianvedoyam/" target="_blank" rel="noopener">LinkedIn</a>
      </div>
    </div>
  </div>

  <!-- Canvas decorativo (opcional, lo dejamos) -->
  <canvas id="bg-net" aria-hidden="true"></canvas>

  <!-- Sentinela para disparar la fase tardía ANTES de llegar a la siguiente sección -->
  <div id="hero-sentinel" aria-hidden="true"></div>

  <script is:inline>
    // Fade-in base del hero
    const root = document.currentScript.closest('.reveal');
    const io0 = new IntersectionObserver((ents)=> {
      for (const e of ents) if (e.isIntersecting) root.classList.add('revealed');
    }, { threshold: 0.1 });
    io0.observe(root);

    // Aparición TEMPRANA de la foto + chips
    const sentinel = document.getElementById('hero-sentinel');
    const late = root.querySelector('.hero-late');
    function placeSentinel() {
      const heroRect = root.getBoundingClientRect();
      sentinel.style.position = 'absolute';
      sentinel.style.top = Math.max(0, heroRect.height * 0.10) + 'px'; // 10% dentro del hero
      sentinel.style.left = '0';
      sentinel.style.right = '0';
      sentinel.style.height = '1px';
      sentinel.style.pointerEvents = 'none';
    }
    placeSentinel();
    window.addEventListener('resize', placeSentinel);

    const io1 = new IntersectionObserver((ents) => {
      for (const e of ents) {
        if (e.isIntersecting) {
          late.classList.add('is-on'); // activa ANTES de llegar a la siguiente sección
          io1.disconnect();
        }
      }
    }, { root: null, threshold: 0, rootMargin: '-10% 0px -80% 0px' });
    io1.observe(sentinel);

    // Canvas de fondo (igual que tu versión anterior)
    const canvas = document.getElementById('bg-net');
    const ctx = canvas.getContext('2d');
    const DPR = window.devicePixelRatio || 1;
    let nodes = [];

    function resizeCanvas() {
      const hero = document.getElementById('inicio');
      const w = hero.clientWidth, h = hero.clientHeight;
      canvas.width = w * DPR;
      canvas.height = h * DPR;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      initNodes();
    }

    function initNodes() {
      const count = 44;
      nodes = [];
      const w = canvas.width, h = canvas.height;
      for (let i = 0; i < count; i++) {
        nodes.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() - 0.5) * 0.18 * DPR, vy: (Math.random() - 0.5) * 0.18 * DPR });
      }
    }

    function step() {
      const w = canvas.width, h = canvas.height;
      for (const n of nodes) {
        n.x += n.vx; n.y += n.vy;
        if (n.x < 0 || n.x > w) n.vx *= -1;
        if (n.y < 0 || n.y > h) n.vy *= -1;
      }
    }

    function draw() {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[i].x - nodes[j].x, dy = nodes[i].y - nodes[j].y;
          const d = Math.hypot(dx, dy);
          const MAX = 180 * DPR;
          if (d < MAX) {
            const alpha = 1 - (d / MAX);
            const gx = ctx.createLinearGradient(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
            gx.addColorStop(0, `rgba(26,77,110,${alpha * 0.16})`);
            gx.addColorStop(1, `rgba(184,115,51,${alpha * 0.16})`);
            ctx.strokeStyle = gx;
            ctx.lineWidth = 1 * DPR;
            ctx.beginPath();
            ctx.moveTo(nodes[i].x, nodes[i].y);
            ctx.lineTo(nodes[j].x, nodes[j].y);
            ctx.stroke();
          }
        }
      }
      for (const n of nodes) {
        ctx.fillStyle = 'rgba(184,115,51,0.42)';
        ctx.beginPath();
        ctx.arc(n.x, n.y, 2.2 * DPR, 0, Math.PI * 2);
        ctx.fill();
      }
      step(); requestAnimationFrame(draw);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); requestAnimationFrame(draw);
  </script>
</section>