---
export interface Props {
  cv?: string;
  foto?: string; // puede venir relativa "/assets/..." o absoluta "https://..."
}

const { cv, foto } = Astro.props;

const cvUrl =
  cv ?? new URL('/files/CV.pdf', Astro.site).pathname;

// üîß Resolver la foto de forma robusta:
const fotoUrl = foto
  ? (foto.startsWith('http')
      ? foto
      : new URL(foto, Astro.site).pathname)
  : new URL('/assets/foto-hero.jpeg', Astro.site).pathname;
---

<section id="inicio" class="hero section reveal">
  <div class="container hero-grid">
    <div class="hero-copy">
      <h1 class="hero-title">
        Sebasti√°n Vedoya M.<br />
        <span class="hero-sub">Comunicaci√≥n Estrat√©gica</span>
      </h1>
      <p class="lead">
        Estratega en comunicaci√≥n con m√°s de 10 a√±os de experiencia en medios y gobierno.
        Me dedico a buscar respuestas complejas para entornos complejos.
      </p>
      <div class="cta-row">
        <!-- ‚úÖ usa cvUrl absoluto y fuerza descarga -->
        <a class="btn" href={cvUrl} download>Descargar CV</a>
        <a class="chip" href="mailto:seba.vedoya@gmail.com">seba.vedoya@gmail.com</a>
        <a class="chip" href="https://www.linkedin.com/in/sebastianvedoyam/" target="_blank" rel="noopener">LinkedIn</a>
      </div>
    </div>

    <div class="hero-photo-wrap">
      <!-- ‚úÖ usa fotoUrl (definido arriba en el frontmatter) -->
      <img src={fotoUrl} alt="Sebasti√°n Vedoya M." loading="lazy" />
    </div>
  </div>

  <canvas id="bg-net" aria-hidden="true"></canvas>

  <script is:inline>
    const obs = new IntersectionObserver((ents)=> {
      for (const e of ents) if (e.isIntersecting) e.target.classList.add('revealed');
    }, { threshold: 0.1 });
    obs.observe(document.currentScript.closest('.reveal'));

    const canvas = document.getElementById('bg-net');
    const ctx = canvas.getContext('2d');
    const DPR = window.devicePixelRatio || 1;
    let nodes = [];

    function resizeCanvas() {
      const hero = document.getElementById('inicio');
      const w = hero.clientWidth, h = hero.clientHeight;
      canvas.width = w * DPR;
      canvas.height = h * DPR;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      initNodes();
    }

    function initNodes() {
      const count = 44;
      nodes = [];
      const w = canvas.width, h = canvas.height;
      for (let i = 0; i < count; i++) {
        nodes.push({ x: Math.random() * w, y: Math.random() * h, vx: (Math.random() - 0.5) * 0.18 * DPR, vy: (Math.random() - 0.5) * 0.18 * DPR });
      }
    }

    function step() {
      const w = canvas.width, h = canvas.height;
      for (const n of nodes) {
        n.x += n.vx; n.y += n.vy;
        if (n.x < 0 || n.x > w) n.vx *= -1;
        if (n.y < 0 || n.y > h) n.vy *= -1;
      }
    }

    function draw() {
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[i].x - nodes[j].x, dy = nodes[i].y - nodes[j].y;
          const d = Math.hypot(dx, dy);
          const MAX = 180 * DPR;
          if (d < MAX) {
            const alpha = 1 - (d / MAX);
            const gx = ctx.createLinearGradient(nodes[i].x, nodes[i].y, nodes[j].x, nodes[j].y);
            gx.addColorStop(0, `rgba(26,77,110,${alpha * 0.16})`);
            gx.addColorStop(1, `rgba(184,115,51,${alpha * 0.16})`);
            ctx.strokeStyle = gx;
            ctx.lineWidth = 1 * DPR;
            ctx.beginPath();
            ctx.moveTo(nodes[i].x, nodes[i].y);
            ctx.lineTo(nodes[j].x, nodes[j].y);
            ctx.stroke();
          }
        }
      }
      for (const n of nodes) {
        ctx.fillStyle = 'rgba(184,115,51,0.42)';
        ctx.beginPath();
        ctx.arc(n.x, n.y, 2.2 * DPR, 0, Math.PI * 2);
        ctx.fill();
      }
      step(); requestAnimationFrame(draw);
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); requestAnimationFrame(draw);
  </script>
</section>