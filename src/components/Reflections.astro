---
/**
 * Reflexiones (Scrollytelling)
 * - Sustituye el formato <details> por scroll progresivo
 * - Reutiliza las clases .scenes-* del global.css
 */

const reflections = [
  {
    id: "ref-ashby",
    title: "La ley de la variedad requerida y el desafío comunicacional contemporáneo",
    body: `La ley de la variedad requerida, postulada por Ross Ashby en 1958, es una de las piedras angulares de la cibernética y una lección vigente para afrontar el entorno comunicativo actual. Según el psiquiatra inglés, un sistema solo puede sobrevivir y mantenerse estable si su capacidad de respuestas al menos iguala la complejidad de las perturbaciones que provienen del entorno.

En términos comunicacionales, ningún actor puede controlar el entorno sin igualarlo en complejidad; y si no puede igualarlo, debe aprender a domesticarlo. Esto último es cada vez más difícil entendiendo la dificultad que existe por controlar la agenda pública. 

Hoy la variedad inunda el entorno a través de innumerables canales, audiencias y especializaciones. Aplicando la enseñanza de Ashby, la ausencia o la pasividad no resuelve conflictos: exige que las estrategias planifiquen y conduzcan a través de múltiples canales y mensajes que contrarresten esa variedad.`
  },
  {
    id: "ref-autoridades",
    title: "Autoridades y redes sociales: una confusión frecuente",
    body: `Pese a lo que muchas autoridades creen, las redes sociales institucional no son su canal de noticias 24/7 a su disposición. Registrar y publicar cada una de sus actividades públicas no solo distrae a los equipos de comunicaciones de lo realmente importante —gestión de prensa, comunicación interna o creación de contenido de valor—, sino que termina generando más bloqueos que los soñados “likes”.

Autoridades de distintos niveles replican este modelo: subsecretarías, seremis, delegaciones, servicios. Parecen clones de lo que no se debe hacer en redes sociales. Si ya existen fuertes resistencias hacia las instituciones estatales, malgastar la oportunidad que ofrece el entorno digital solo amplía esa distancia.

Liberen a sus equipos. Permítanles crear. Si una reunión no se publica, nadie la extrañará. Si logran comunicar los logros de gestión con simpatía y cercanía, construirán comunidad y obtendrán la visibilidad que buscan. No todo gira sobre ustedes. ¿O acaso vemos al gerente de una gran empresa de telefonía o retail subiendo cada minuto de su itinerario?`
  },
  {
    id: "ref-miedo",
    title: "Comunicar sin miedo",
    body: `Durante una visita a Rapa Nui tuve la oportunidad de entrevistar a la alcaldesa Elizabeth Arévalo Pakarati. Terminada la conversación, mi reacción fue inmediata: ya quisiera cualquier político o directivo de empresa su capacidad de comunicar, le dije. Todo funcionó perfecto. Su vestimenta, postura, tono y locuacidad —del latín loquax, “el que tiene facilidad de palabra”— demostraban un trabajo constante y dedicado. Lejos de parecer una imagen artificial, solo irradiaba seguridad en sí misma.

Su ejemplo no solo merece reconocimiento, sino que sirve para contrastar con el temor y la desconfianza con que muchas autoridades enfrentan la responsabilidad de comunicar. Cada vez son más quienes anteponen la precaución por sobre la oportunidad. El miedo al cuestionamiento, la contrapregunta, el tuit o la columna del día siguiente inmoviliza e impide aprovechar la posibilidad de conectar con todo tipo de públicos. 

La falta de preparación o costumbre puede ser una explicación, pero el problema parece más profundo: el temor a exponerse y la distancia que puede generar asumir un cargo de alta responsabilidad.
Tomemos un ejemplo simple: visitar una localidad aislada, nunca antes recorrida por una autoridad, debería ser visto como una oportunidad para conectar, no como un riesgo de crítica. En la práctica, los temores no se cumplen en un 99 % de los casos. Y si se cumplen, un vocero preparado y en escucha activa puede revertirlos en su gran mayoría. 

La comunicación es el principal vehículo entre la comunidad y sus autoridades. Ignorarla, evadirla o subestimarla genera costos. Mejor seguir el ejemplo de la alcaldesa de Rapa Nui y asumirla con la seriedad —y la confianza— que merece.`
  }
];
---

<section id="reflexiones" class="section scenes">
  <div class="container scenes-layout">
    <h2 class="h2" style="grid-column:1 / -1; margin-bottom:.25rem;">Reflexiones</h2>

    <!-- Barra de progreso -->
    <aside class="scenes-progress" aria-hidden="true">
      <div class="progress-track">
        <div class="progress-thumb" id="progressReflexiones"></div>
      </div>
      <ul class="progress-labels" id="labelsReflexiones">
        {reflections.map((r, i) => <li class="progress-label" data-index={i}>{r.title}</li>)}
      </ul>
    </aside>

    <!-- Secciones -->
    <div class="scenes-col" id="colReflexiones">
      {reflections.map((r, i) => (
        <article class="scene reveal" id={r.id} data-index={i} aria-current="false">
          <header class="pin-step-head">
            <span class="step-index">{String(i+1).padStart(2,"0")}</span>
            <h3 style="margin: .2rem 0 .5rem; font-weight:800;">{r.title}</h3>
          </header>
          <p class="pin-step-text" style="white-space:pre-wrap">{r.body}</p>
        </article>
      ))}
    </div>
  </div>
</section>

<script is:inline>
  const col    = document.getElementById('colReflexiones');
  const scenes = Array.from(col.querySelectorAll('.scene'));
  const bar    = document.getElementById('progressReflexiones');
  const labels = Array.from(document.getElementById('labelsReflexiones').children);

  const active = new Set();

  const io = new IntersectionObserver((entries)=>{
    for(const e of entries){
      const el = e.target;
      if(e.isIntersecting){ active.add(el); } else { active.delete(el); }
      const current = [...active].sort((a,b)=> a.dataset.index - b.dataset.index).at(-1);
      if(current){
        scenes.forEach(sc => sc.classList.toggle('is-active', sc === current));
        labels.forEach((lb, i) => lb.classList.toggle('is-on', i <= Number(current.dataset.index)));

        const p = (Number(current.dataset.index)+1) / scenes.length;
        bar.style.transform = `scaleY(${Math.max(0.05, p)})`;
      }
    }
  }, { rootMargin: "-30% 0px -30% 0px", threshold: 0.55 });

  scenes.forEach(s => io.observe(s));

  const ap = new IntersectionObserver((es)=>{
    for(const e of es) e.target.classList.toggle("reveal--in", e.isIntersecting);
  }, { threshold: 0.2 });
  scenes.forEach(el => ap.observe(el));
</script>